Source Code
===========

This file describes elements of the Source Code. It explains
their role in the program and talks briefly about their inner
workings.

Files with source code controlled by Visual Studio, ie.
`*.Designer.cs`, `*.resx`, are omitted from the description.
Their source code is generated through visual controls.
They are accompanied by sibling files that have code written by hand.

Tech Choices
============

My usual "go to" for desktop apps is `C++` + `CMake` + `Qt` trio, as I
usually care that the program works on at least 2 Operating Systems:
Windows and Linux. In this case I wanted a stricte Windows app. As much
as Qt makes it easier to develop apps, and as much as C++14 has pushed
the comfort of using the language forward, there's still some
boiler-plate needed to even get the project up and there's still some
scaffolding needed to be built before you can focus on the problem at
hand.

C#, which is excellently supported by Visual Studio, gives you
the benefit of nearly immediately focusing on solving the actual
problem you want to solve. Benefits of C#, Visual Studio and .NET
platform:

* Excellent visual form editor for WinForms.
* Excellent code auto-completion.
* Standard library solves most of the boring and tricky
  problems for you.
* Managed memory environment.
* C# structs (copy on assign).
* C# properties.
* Exceptions with useful stack traces.
* Static typing, allowing the compiler to detect many errors for you
  before the runtime.

Cons:

* Microsoft proposed way for naming uses PascalCase.
    * It's pervasive. Name collisions can occur between ClassNames,
      MethodNames and ConstNames.
    * Even Simple, One Letter Names force you to press the `SHIFT` key.
* Even though there's 'mono' for Linux, this particular
  program calls the native `DestroyIcon` which immediately
  causes it to crash. It also remains untested if mono
  on Linux provides the traffic statistics.
  _(only relevant if I wanted to release a Linux version, which I don't)_
  _(2026 update: this was relevant in 2018, I don't know what's the state of that now)_

The initial, fully-working version of the program, sans bugs,
was done in less than 24 hours. I'm sure someone better versed
in this tech could do this much faster.

Code style adopts Microsoft recommendations.  
<https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names>
_(Accessed: 2026-01)_

Section A - UI and utilities
============================

[Program.cs](PikPikMeter/Program.cs)
====================================

This is the standard "main" file generated by Visual Studio.
It has the `Main()` function, it starts the main form (main
window) and that's pretty much it.

Moving on.

[MainWindow.cs](PikPikMeter/MainWindow.cs)
==========================================

The Main Window, sometimes known as "The Dreaded God Object".
I always find `MainWindow` classes to be the most difficult to code.
They bind the main user interface, with all the menus, task bar handling,
tray handling, minimize/maximize/normalize events, various dialog boxes,
context menus, tray icon, etc. With all this stuff happening in a single
place, `MainWindow` very quickly gets crammed with many different
attributes and methods that do different, small jobs. None of them can
be easily disconnected from the `MainWindow`.

Elegant solutions for `MainWindow` are not easy to achieve.

Let's summarize what `MainWindow` in PikPikMeter does:

* Lays out of all widgets.
* Customizes the handling of moving and resizing the window. In PikPikMeter,
  the usual window "resize" border and title bar are turned off, so there's
  explicit code to handle mouse events and do that.
* `LoadSettings`/`SaveSettings`.
* Controls `MainWindow's` opacity and provide slider & context menu
  action to allow user to change it.
* Sets up the `TrafficMonitor`, which takes over statistics gathering,
  graph painting and label updates.
* Allows to set traffic unit scale of the graph and bytes/bits
  option of labels.
* Ticks a refresh `Timer` that ticks the `TrafficMonitor`.
* Controls the "top most" flag of itself.
* Is capable of bringing itself to front (of other windows in Windows).
* Toggles "start with system" flag via `SystemStart`.
* Toggles Network Interface monitoring on user's behest.

The very length of this description suggests that MainWindow
has a lot to do.

SaveSettings/LoadSettings in MainWindow
---------------------------------------

These operations have nothing to do with "MainWindowing", but because
`MainWindow` is at the topmost level of the source code, it can also
access all the objects used in the program. I opted not to reference
C#'s `Settings` singleton anywhere else in the code but here. It makes
the other objects decoupled and allows to configure them in different
ways if needed. MainWindow references all `Settings` values and
assigns them to appropriate attributes of other objects. When `closing`
event is received, it takes those attributes back and saves them
through the usual .NET means - in an XML file in `%LOCALAPPDATA%`.

[ScreenPosition](PikPikMeter/ScreenPosition.cs)
===============================================

In order to delegate some responsibility away from `MainWindow`,
the screen positioning is actually controlled here. Default screen
position, as well as minimal window size, are defined here.

This class also implements `MainWindow` position validation check,
and a method to reposition the window to the default location.
If user configuration contains an invalid position - a Window is outside
of the visible area - it will try to reposition the Window back to the
default location. It will also prevent the window from going below its
minimal size. This last thing could also be controlled by setting
the minimal size attribute in `MainWindow` form designer, however
I wanted to have the screen positioning logic in one place.

`ScreenPosition` also takes multi-screens into account. When calculating
default window position, it will try to use the screen that contains
the mouse cursor.

[About.cs](PikPikMeter/About.cs)
================================

The About window contains:

* Program's name, version and development date span, i.e.,
  a span of years during which the program was developed.
* Copyright information - who made this, how to contact them.
* License info.
* Link to program's or author's website.
* The information should be easy to copy & paste or at least
  easy to write down from screen.

Program name and version are extracted from `Application`
class, kindly provided to us by the .NET platform. This
information is configured in project's configuration
in Visual Studio.

The license contents are incorporated into the executable
as a resource and retrieved using the `Resources` class.
The content of this file is ASCII, so I use UTF-8 decoder
to decode it. Always mind the encoding of the text you read and write!

Another thing is to make sure that About window closes when you press
`Escape` key on keyboard.

The About window is also allowed to follow a different visual theme
than the rest of the program. It's okay to use the standard Windows
theming here.

[AskValue.cs](PikPikMeter/AskValue.cs)
======================================

This is a generic "value input" dialog box that can be reused
for getting many different values from the user.

It's possible to set the label text placed directly above the
input box and also the contents of the input box.

It's currently not possible to change the type of the input box, to change
its value masking (i.e., ask for passwords) or to assign a validator.

The window will "Cancel" itself when pressing `Escape` and
"Accept" when pressing `Enter`. This is done by marking "Ok" button
and "Cancel" button with appropriate C#'s `DialogResult` values.

In PikPikMeter this window also follows the default Windows visual theme.

[SystemStart.cs](PikPikMeter/SystemStart.cs)
============================================

In an effort to further de-deityize `MainWindow`, `SystemStart` is
a small class that contains only one, static property: `On`.

When you do:

```C#
SystemStart.On = true;
```

`SystemStart` will try to write a `CurrentVersion\Run` registry entry
using `Assembly.GetExecutingAssembly().GetName().Name` property
as registry setting name, and `Application.ExecutablePath`
as registry setting value. The set value is extra-wrapped in
double-quotation marks.

Doing:

```C#
SystemStart.On = false;
```

will remove the registry entry.

It's also possible to get the current state of the registry entry by
getting the property:

```C#
bool isSystemStart = SystemStart.On;
```

Upon this, the property will try to open the registry key for reading
and check if the setting is there and if it points to the same
executable as `Application.ExecutablePath`. If any `Exception` occurs,
it's converted to `false` return value, which is a bit of a programming
anti-pattern, but I'd rather have the program not crash.

[History.cs](PikPikMeter/History.cs)
====================================

Under this grandiose name hides a generic LIFO collection implementation
with limited maximum size. When new elements are added to the collection
and the maximum size is exceeded, the oldest elements are removed.

The `History` collection is used to accumulate traffic statistics.

[Resources](PikPikMeter/Resources/)
===================================

Icons, resizer and a copy of the LICENSE - this last one is
to satisfy Visual Studio's need of cramming it there. LICENSE
normally resides in the root dir of the repository.

Pictures were drawn in GIMP.

`ico` files were then created in IcoFX 1.6.4 - the last Freeware
version of this program.

Section B - Traffic Monitoring
==============================

The program needs to do several jobs in something that
could be described as a "pipeline" in order to show
the traffic measures to the user. Let's list them:

* Read the current traffic stats as provided by Windows.
* Accumulate them in a history collection for graph painting.
* Toggle monitoring of each Network Interface on demand.
* Handle Network Interfaces going down (disappearing) or up (appearing).
* Paint the history graph.
* Display current traffic in labels.
* Scale the traffic to a preset unit size and type.

These responsibilities are spread between several `Traffic*` classes
in an attempt to follow the **SRP** in **SOLID**.

[TrafficUnit.cs](PikPikMeter/TrafficUnit.cs)
============================================

When the program needs to display size and accept size as user input,
it's a good idea to have conversion mechanism between different
units of said size. `TrafficUnit` `Humanize()` converts size in Bytes
or bits to Kilo, Mega and Giga sizes that are easier to understand for
the reader. It can also `Parse()` said scaled values back into
a `TrafficUnitValue` struct that conveys the size information in
scale understood by program either in Bytes or bits.

Conversions honor the current locale.

[TrafficNic.cs](PikPikmeter/TrafficNic.cs)
==========================================

Access point to the `System.Diagnostics` API. Responsibilities are:

* List all Network Interfaces currently available in the system.
* Track each Network Interface in a separate object, allowing
  to get a traffic measure snapshot with `Measure()` method.

Measures are returned as `TrafficNicMeasure` structs and
errors are thrown as `TrafficMeasureException` exceptions.

[TrafficNicMeasure.cs](PikPikMeter/TrafficNicMeasure.cs)
========================================================

One measure taken from a Network Interface. Carries over
name of that Interface and traffic stats.

[TrafficMeasureException.cs](PikPikMeter/TrafficMeasureException.cs)
====================================================================

Whenever a measure error happens, for example when OS reports
a problem with traffic stats grabbing, it will be captured
by the immediate code and re-raised as this exception. This
exception is further captured and handled to avoid program
crashes and to recover from error states.

An error recovery happens when Network Interfaces go down.
When this happens, exception is captured and list of Interfaces
is refreshed in hopes that the program can continue normally with
the new list.

The Interfaces are also refreshed with each grab because
it is unknown when a new Network Interface will go up.
To reduce Garbage Collector work, objects for Interfaces
that do not change state are preserved.

[TrafficGrabber.cs](PikPikMeter/TrafficGrabber.cs)
==================================================

`TrafficGrabber` collects `TrafficNic` instances. It keeps exactly
one `TrafficNic` instance per Network Interface. When a measure
is to be taken, its job is to iterate over all `TrafficNic` it has,
query them for measures and then return those measures in a
collection. If during this grab an error occurs, it will refresh
the list of Network Interfaces, destroy all current `TrafficNic`
objects and create new ones.

Nature of both `TrafficGrabber` and `TrafficNic` is immediate.
They exist and are useful in given instant and can be safely destroyed
and recreated as needed.

[TrafficStat.cs](PikPikMeter/TrafficStat.cs)
============================================

`TrafficStat`'s job is to accept immediate collections
of `TrafficNicMeasure` structs and store them in history, allowing
other parts of the program to retrieve valuable information from that
history.

In PikPikMeter, the graph, or any traffic label, is intended to display
system totals. It doesn't actually care what Network Interface the
traffic comes from. It always displays whole traffic in the system,
visible on all Network Interfaces. The individual NIC stats are summed
up to "System Totals". These totals are stored as `StatMeasure` structs.

The totals do track the individual measures because there are cases
where the totals must be recalculated. Such recalculation can happen
when user toggles monitoring of specific Network Interfaces. Internally,
PikPikMeter always monitors all Network Interfaces. Toggling their
"monitored" state in program's options only toggles their inclusion in
the totals. Thanks to this, the display of the program can be changed
to include or exclude history of specific Network Interface at user's
whim.

This mechanism also helps to preserve the history for Network Interfaces
that go down and then back up.

[TrafficMasterMonitor.cs](PikPikMeter/TrafficMasterMonitor.cs)
==============================================================

This binds the UI with the traffic measures. It is also another attempt
to reduce the godobjectifity of `MainWindow`.

`TrafficMasterMonitor` instantiates the measurement `TrafficGrabber`
and history `TrafficStat` mechanisms, accepts references
to display controls located in `MainWindow`, updates them
when needed and paints graphs using `TrafficGraphPaint`.

`TrafficMasterMonitor` doesn't `Tick()` on its own. Each refresh
needs to be triggered externally. `MainWindow` has a `Timer` to
do just that.

The refresh process, or `Tick()`, does this in each iteration:

1. Grabs current traffic measures from OS.
2. Stores them in history.
3. Updates displays.

There's also a `Repaint()` method for when `MainWindow` wants
the display to be repainted without grabbing new measures.
This is useful when `MainWindow` is resized or certain
options such as scale or tray icon painting get toggled.

`TrafficMasterMonitor` exposes some of its internals because
`MainWindow` in its `LoadSettings`/`SaveSettings` phases accesses
those internals to apply or read the actual setting values.

Word "master" in its name underlines the hierarchy position
of this class. It's the border between the UI and the internals.

Graph painting doesn't happen here directly as this process
is complicated enough that it deserves a separate source code unit.

[TrafficGraphPaint.cs](PikPikMeter/TrafficGraphPaint.cs)
========================================================

Last, but not least, is the graph painter.

Its job is to paint both the main graph and the graph on
the tray icon. It controls the colors for each traffic unit,
the size of the traffic bars, the actual scale of the display
(also for the labels, which are updated by `TrafficMasterMonitor`).
It also prints the scale text on the graph, but only if
there's enough space to display it.

The painter will only paint as many measures as there are pixels
in the graph's width. Each measure is exactly one pixel wide.
Graph bars also stick to the right edge of the graph, thus
it always appears that the graph is moving left. The painter
chooses which traffic type - upload or download - is greater
in given measure and will paint this type in its own color
(red or green) and then overpaint the overlapping size in a common
color (yellow).

Each paint causes the complete clear of the graph and a complete
repaint. It doesn't reuse the already painted history by blitting
it left.

The colors are technically configurable in the class itself,
but the program doesn't provide any user interface to do so,
therefore the colors are hardcoded and cannot be changed without
editing the source code.
